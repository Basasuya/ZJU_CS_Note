# 2.3 进程同步

* **临界区**指的是访问临界资源的那段代码，临界资源指的是一次仅仅允许一个进程使用的资源
* **同步和互斥**是进程最关键的两个方面，同步指的是两个进程之间的相互制约先后次序，互斥则是两个进程之间访问临界资源的时候不能同时访问
* **互斥**需要满足四个方面，空闲让进，忙则等待，有限等待，让权等待(等待的时候不能占用处理机资源)

#### 1.实现临界区互斥的方法

* 软件实现方式，四种算法，p73页，非常的重要，分别违背了四个方面的内容

> 其中正确的算法，Peterson's Algorithm

```c++
flag[i] = 1; turn = j;
while(flag[j] && turn == j);
solve();
flage[i] = 0;
```

* 硬件实现方法，有中断屏蔽，硬件指令两种

> TestanSet和Swap两种方法，缺点是可能导饥饿

#### 2.信号量

* 是最理想的机制来解决同步和互斥的问题，是一种原语，也就是说，无法中断
* 整型信号量(wait sign)存在让权等待的问题，而记录型信号量不存在这个问题

> wait操作相当于申请资源，而sign操作相当于释放资源，和pv操作类似

#### 3.管程

* 管程氏一组定义在这组数据上的对这组数据的做操作的软件模块，能够初始化并改变管程的数据，并**同步**进程
* 管程每次只允许一个进程进入，管程的signal操作是和V操作**不一样**的，因为管程实质上是一种软件，也也就是说不像原语一样，是可以被阻塞中断的
* 类似于C++中的抽象类

#### 4.PV操作

* 对于信号量的一种抽象的理解，**信号量的大小相当于一个停车场中剩余的车位，而信号量为负的时候就意味着有多少人正在外面排队**
* 生产者消费者问题，互斥问题，同步问题

> p92 4 9 10 11 12 15 17 19 20 22
>
> 互斥问题，对于同一个变量的控制必须使用mutex
>
> 同步问题，对于单容量的，无限容量的容器我可以单信号量，但是只要固定容量，就是需要双信号量进行控制
>
> 如果牵涉多个东西的取，必须一个个来
>
> 请求服务可以专门多些一个信号量

* 写者读者 count控制问题

> p92  13 18

* 哲学家筷子问题，吸烟者问题